<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§© å…«æ•°å­—æ¨ç›˜é—®é¢˜ - A* ç®—æ³•å¯è§†åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.2em;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 25px;
            font-size: 1.1em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 20px;
        }

        .puzzle-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.05);
        }

        .section-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #2c3e50;
            font-weight: 600;
        }

        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 5px;
            margin: 0 auto;
            width: fit-content;
            background: #34495e;
            padding: 5px;
            border-radius: 10px;
        }

        .puzzle-tile {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .puzzle-tile:hover {
            transform: scale(1.05);
        }

        .puzzle-tile.empty {
            background: rgba(52, 73, 94, 0.3);
            cursor: default;
        }

        .puzzle-tile.empty:hover {
            transform: none;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85em;
            opacity: 0.9;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            margin-top: 5px;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 30px;
            font-size: 1em;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            color: white;
            transition: all 0.3s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-solve {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-step {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .btn-reset {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-shuffle {
            background: linear-gradient(135deg, #ff9800 0%, #ff5722 100%);
        }

        .status {
            text-align: center;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 10px;
            font-size: 1.05em;
            color: #2e7d32;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .status.solving {
            background: #fff3e0;
            color: #e65100;
            animation: pulse 1.5s infinite;
        }

        .status.solved {
            background: #c8e6c9;
            color: #1b5e20;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .algorithm-viz {
            background: white;
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #e0e0e0;
            max-height: 400px;
            overflow-y: auto;
        }

        .search-node {
            background: #f5f5f5;
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .search-node.current {
            background: #fff3e0;
            border-left-color: #ff9800;
            border-left-width: 6px;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
            transform: scale(1.02);
        }

        .search-node.solution {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }

        .explanation {
            background: #fff9c4;
            border-left: 4px solid #fbc02d;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
            color: #5d4037;
            line-height: 1.8;
        }

        .explanation h4 {
            color: #f57f17;
            margin-bottom: 8px;
        }

        .formula {
            background: rgba(102, 126, 234, 0.1);
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            text-align: center;
            font-size: 1.05em;
            color: #667eea;
        }

        .mini-puzzle {
            display: inline-grid;
            grid-template-columns: repeat(3, 20px);
            grid-template-rows: repeat(3, 20px);
            gap: 2px;
            background: #34495e;
            padding: 2px;
            border-radius: 3px;
            vertical-align: middle;
        }

        .mini-tile {
            background: #667eea;
            color: white;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
        }

        .mini-tile.empty {
            background: rgba(52, 73, 94, 0.3);
        }

        .github-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.25) !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§© å…«æ•°å­—æ¨ç›˜é—®é¢˜</h1>
        <p class="subtitle">A* æœç´¢ç®—æ³•å¯è§†åŒ–æ¼”ç¤º</p>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">å·²æ¢ç´¢çŠ¶æ€</div>
                <div class="stat-value" id="exploredCount">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">å½“å‰æ­¥æ•°</div>
                <div class="stat-value" id="moveCount">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">å¯å‘å€¼ (h)</div>
                <div class="stat-value" id="heuristicValue">-</div>
            </div>
        </div>

        <div class="main-grid">
            <div class="puzzle-section">
                <div class="section-title">å½“å‰çŠ¶æ€</div>
                <div class="puzzle-grid" id="currentPuzzle"></div>
                <div style="text-align: center; margin-top: 15px; color: #7f8c8d;">
                    ç‚¹å‡»æ•°å­—å¯ç§»åŠ¨åˆ°ç©ºæ ¼
                </div>
                
                <!-- è®¡ç®—è¿‡ç¨‹å¯è§†åŒ– -->
                <div style="margin-top: 20px; background: white; padding: 15px; border-radius: 12px; border: 2px solid #e0e0e0;">
                    <div style="font-weight: 600; color: #2c3e50; margin-bottom: 10px;">ğŸ“Š è¯„ä¼°å€¼è®¡ç®—è¿‡ç¨‹</div>
                    
                    <!-- g å€¼ -->
                    <div style="margin: 10px 0; padding: 10px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
                        <div style="font-weight: 600; color: #1976d2;">g(n) = å·²èµ°æ­¥æ•°</div>
                        <div id="gCalc" style="margin-top: 5px; color: #555; font-size: 0.95em;"></div>
                    </div>
                    
                    <!-- h å€¼ -->
                    <div style="margin: 10px 0; padding: 10px; background: #fff3e0; border-radius: 8px; border-left: 4px solid #ff9800;">
                        <div style="font-weight: 600; color: #f57c00;">h(n) = æ›¼å“ˆé¡¿è·ç¦»</div>
                        <div id="hCalc" style="margin-top: 5px; color: #555; font-size: 0.9em;"></div>
                    </div>
                    
                    <!-- f å€¼ -->
                    <div style="margin: 10px 0; padding: 10px; background: #f3e5f5; border-radius: 8px; border-left: 4px solid #9c27b0;">
                        <div style="font-weight: 600; color: #7b1fa2;">f(n) = g(n) + h(n)</div>
                        <div id="fCalc" style="margin-top: 5px; color: #555; font-size: 0.95em; font-weight: 600;"></div>
                    </div>
                    
                    <!-- ä¸‹ä¸€æ­¥é€‰æ‹© -->
                    <div id="nextMoveSection" style="margin: 10px 0; padding: 10px; background: #e8f5e9; border-radius: 8px; border-left: 4px solid #4caf50;">
                        <div style="font-weight: 600; color: #2e7d32;">ğŸ¯ A* ç®—æ³•ä¼šé€‰æ‹©å“ªä¸€æ­¥ï¼Ÿ</div>
                        <div id="nextMoveCalc" style="margin-top: 5px; color: #555; font-size: 0.9em;"></div>
                    </div>
                </div>
            </div>

            <div class="puzzle-section">
                <div class="section-title">ç›®æ ‡çŠ¶æ€</div>
                <div class="puzzle-grid" id="goalPuzzle"></div>
                <div class="formula" style="margin-top: 15px;">
                    f(n) = g(n) + h(n)
                    <div style="font-size: 0.85em; margin-top: 5px; color: #7f8c8d;">
                        f: æ€»ä»£ä»· | g: å·²èµ°æ­¥æ•° | h: æ›¼å“ˆé¡¿è·ç¦»
                    </div>
                </div>
                
                <!-- æ›¼å“ˆé¡¿è·ç¦»å¯è§†åŒ– -->
                <div style="margin-top: 20px; background: white; padding: 15px; border-radius: 12px; border: 2px solid #e0e0e0;">
                    <div style="font-weight: 600; color: #2c3e50; margin-bottom: 10px;">ğŸ“ æ›¼å“ˆé¡¿è·ç¦»è¯¦è§£</div>
                    <canvas id="manhattanViz" width="300" height="300" style="width: 100%; max-width: 300px; margin: 0 auto; display: block;"></canvas>
                    <div id="manhattanDetails" style="margin-top: 10px; font-size: 0.85em; color: #666;"></div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn-shuffle" onclick="shufflePuzzle()">ğŸ”€ æ‰“ä¹±</button>
            <button class="btn-solve" onclick="solve()" id="solveBtn">ğŸš€ æ±‚è§£</button>
            <button class="btn-step" onclick="step()" id="stepBtn" disabled>â­ï¸ å•æ­¥æ‰§è¡Œ</button>
            <button class="btn-solve" onclick="autoPlay()" id="playBtn" disabled>â–¶ï¸ è‡ªåŠ¨æ’­æ”¾</button>
            <button class="btn-reset" onclick="reset()">ğŸ”„ é‡ç½®</button>
        </div>

        <div class="status" id="status">
            ç‚¹å‡»ã€Œæ‰“ä¹±ã€å¼€å§‹ï¼Œæˆ–æ‰‹åŠ¨ç§»åŠ¨æ•°å­—
        </div>

        <div class="puzzle-section">
            <div class="section-title">æœç´¢è¿‡ç¨‹</div>
            <div class="algorithm-viz" id="searchLog"></div>
        </div>

        <div class="explanation">
            <h4>ğŸ’¡ A* æœç´¢ç®—æ³•åŸç†</h4>
            <p>
                <strong>A* ç®—æ³•</strong>æ˜¯ä¸€ç§å¯å‘å¼æœç´¢ç®—æ³•ï¼Œç»“åˆäº† Dijkstra ç®—æ³•å’Œè´ªå¿ƒæœ€ä½³ä¼˜å…ˆæœç´¢ï¼š
            </p>
            <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                <li><strong>f(n) = g(n) + h(n)</strong> - è¯„ä¼°å‡½æ•°</li>
                <li><strong>g(n)</strong> - ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„å®é™…ä»£ä»·ï¼ˆå·²èµ°æ­¥æ•°ï¼‰</li>
                <li><strong>h(n)</strong> - ä»å½“å‰èŠ‚ç‚¹åˆ°ç›®æ ‡çš„ä¼°è®¡ä»£ä»·ï¼ˆå¯å‘å¼å‡½æ•°ï¼‰</li>
                <li><strong>æ›¼å“ˆé¡¿è·ç¦»</strong> - æ‰€æœ‰æ•°å­—åˆ°ç›®æ ‡ä½ç½®çš„è·ç¦»ä¹‹å’Œ</li>
            </ul>
            <p style="margin-top: 10px;">
                ç®—æ³•æ€»æ˜¯ä¼˜å…ˆæ¢ç´¢ f å€¼æœ€å°çš„çŠ¶æ€ï¼Œä¿è¯æ‰¾åˆ°æœ€ä¼˜è§£ï¼
            </p>
        </div>

        <div style="margin-top: 30px; padding: 20px; text-align: center; border-top: 2px solid #e0e0e0;">
            <a href="https://github.com/happydog-intj/ai-learning-pages" target="_blank" class="github-link" style="display: inline-flex; align-items: center; gap: 8px; padding: 12px 24px; background: linear-gradient(135deg, #24292e 0%, #3d4349 100%); color: white; text-decoration: none; border-radius: 10px; font-weight: 600; transition: all 0.3s; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
                <svg height="24" width="24" viewBox="0 0 16 16" fill="currentColor">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                <span>View on GitHub</span>
            </a>
        </div>
    </div>

    <script>
        // å…«æ•°å­—æ¨ç›˜çŠ¶æ€
        class PuzzleState {
            constructor(board, emptyPos, g = 0, parent = null) {
                this.board = board; // 3x3 æ•°ç»„
                this.emptyPos = emptyPos; // [row, col]
                this.g = g; // å·²èµ°æ­¥æ•°
                this.parent = parent; // çˆ¶çŠ¶æ€
                this.h = this.calculateHeuristic();
                this.f = this.g + this.h;
            }

            // è®¡ç®—æ›¼å“ˆé¡¿è·ç¦»ï¼ˆå¯å‘å¼å‡½æ•°ï¼‰
            calculateHeuristic() {
                let distance = 0;
                const goal = [[1,2,3],[4,5,6],[7,8,0]];
                
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const value = this.board[i][j];
                        if (value !== 0) {
                            // æ‰¾åˆ°ç›®æ ‡ä½ç½®
                            for (let gi = 0; gi < 3; gi++) {
                                for (let gj = 0; gj < 3; gj++) {
                                    if (goal[gi][gj] === value) {
                                        distance += Math.abs(i - gi) + Math.abs(j - gj);
                                    }
                                }
                            }
                        }
                    }
                }
                return distance;
            }

            // è·å–å¯èƒ½çš„ç§»åŠ¨
            getMoves() {
                const moves = [];
                const [row, col] = this.emptyPos;
                const directions = [[-1,0], [1,0], [0,-1], [0,1]]; // ä¸Šä¸‹å·¦å³
                
                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {
                        const newBoard = this.board.map(r => [...r]);
                        // äº¤æ¢
                        newBoard[row][col] = newBoard[newRow][newCol];
                        newBoard[newRow][newCol] = 0;
                        
                        moves.push(new PuzzleState(
                            newBoard,
                            [newRow, newCol],
                            this.g + 1,
                            this
                        ));
                    }
                }
                return moves;
            }

            // è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼ˆç”¨äºå»é‡ï¼‰
            toString() {
                return this.board.flat().join(',');
            }

            // æ£€æŸ¥æ˜¯å¦ä¸ºç›®æ ‡çŠ¶æ€
            isGoal() {
                const goal = '1,2,3,4,5,6,7,8,0';
                return this.toString() === goal;
            }
        }

        // å…¨å±€çŠ¶æ€
        let currentState = null;
        let solution = null;
        let solutionIndex = 0;
        let exploredStates = 0;
        let animationRunning = false;

        const GOAL_BOARD = [[1,2,3],[4,5,6],[7,8,0]];

        // åˆå§‹åŒ–
        function init() {
            currentState = new PuzzleState(
                [[1,2,3],[4,5,6],[7,8,0]],
                [2, 2]
            );
            renderPuzzle('currentPuzzle', currentState.board, true);
            renderPuzzle('goalPuzzle', GOAL_BOARD, false);
            updateStats();
        }

        // æ¸²æŸ“æ‹¼å›¾
        function renderPuzzle(containerId, board, interactive) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const tile = document.createElement('div');
                    tile.className = 'puzzle-tile';
                    
                    if (board[i][j] === 0) {
                        tile.classList.add('empty');
                    } else {
                        tile.textContent = board[i][j];
                        if (interactive) {
                            tile.onclick = () => moveTile(i, j);
                        }
                    }
                    
                    container.appendChild(tile);
                }
            }
        }

        // æ‰‹åŠ¨ç§»åŠ¨æ•°å­—
        function moveTile(row, col) {
            if (animationRunning) return;
            
            const [emptyRow, emptyCol] = currentState.emptyPos;
            const distance = Math.abs(row - emptyRow) + Math.abs(col - emptyCol);
            
            if (distance === 1) {
                const newBoard = currentState.board.map(r => [...r]);
                newBoard[emptyRow][emptyCol] = newBoard[row][col];
                newBoard[row][col] = 0;
                
                currentState = new PuzzleState(newBoard, [row, col], currentState.g + 1);
                renderPuzzle('currentPuzzle', currentState.board, true);
                updateStats();
                
                if (currentState.isGoal()) {
                    document.getElementById('status').className = 'status solved';
                    document.getElementById('status').textContent = 'ğŸ‰ æ­å–œï¼æ‚¨æ‰‹åŠ¨è§£å†³äº†æ‹¼å›¾ï¼';
                }
            }
        }

        // æ‰“ä¹±æ‹¼å›¾
        function shufflePuzzle() {
            reset();
            const moves = 20 + Math.floor(Math.random() * 20);
            
            for (let i = 0; i < moves; i++) {
                const possibleMoves = currentState.getMoves();
                if (possibleMoves.length > 0) {
                    currentState = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }
            }
            
            currentState.g = 0; // é‡ç½®æ­¥æ•°
            renderPuzzle('currentPuzzle', currentState.board, true);
            updateStats();
            document.getElementById('status').textContent = 'å·²æ‰“ä¹±ï¼ç‚¹å‡»ã€Œè‡ªåŠ¨æ±‚è§£ã€æŸ¥çœ‹ç®—æ³•å¦‚ä½•è§£å†³';
        }

        // A* æœç´¢ç®—æ³•
        function aStarSearch(startState) {
            const openList = [startState];
            const closedSet = new Set();
            const openSet = new Set([startState.toString()]);
            exploredStates = 0;
            
            document.getElementById('searchLog').innerHTML = '';
            
            while (openList.length > 0) {
                // æ‰¾åˆ° f å€¼æœ€å°çš„çŠ¶æ€
                openList.sort((a, b) => a.f - b.f);
                const current = openList.shift();
                openSet.delete(current.toString());
                
                exploredStates++;
                logSearchStep(current, false);
                
                if (current.isGoal()) {
                    logSearchStep(current, true);
                    return reconstructPath(current);
                }
                
                closedSet.add(current.toString());
                
                for (const neighbor of current.getMoves()) {
                    const neighborStr = neighbor.toString();
                    
                    if (closedSet.has(neighborStr)) continue;
                    
                    if (!openSet.has(neighborStr)) {
                        openList.push(neighbor);
                        openSet.add(neighborStr);
                    }
                }
            }
            
            return null; // æ— è§£
        }

        // é‡å»ºè·¯å¾„
        function reconstructPath(state) {
            const path = [];
            let current = state;
            
            while (current) {
                path.unshift(current);
                current = current.parent;
            }
            
            return path;
        }

        // è®°å½•æœç´¢æ­¥éª¤
        function logSearchStep(state, isSolution) {
            const log = document.getElementById('searchLog');
            const entry = document.createElement('div');
            entry.className = 'search-node';
            if (isSolution) entry.classList.add('solution');
            
            const miniPuzzle = createMiniPuzzle(state.board);
            entry.innerHTML = `
                ${miniPuzzle}
                <span style="margin-left: 10px;">
                    g=${state.g} h=${state.h} f=${state.f}
                    ${isSolution ? '<strong style="color: #4caf50;">âœ“ æ‰¾åˆ°è§£ï¼</strong>' : ''}
                </span>
            `;
            
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // åˆ›å»ºå°å‹æ‹¼å›¾æ˜¾ç¤º
        function createMiniPuzzle(board) {
            let html = '<div class="mini-puzzle">';
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const value = board[i][j];
                    html += `<div class="mini-tile ${value === 0 ? 'empty' : ''}">${value || ''}</div>`;
                }
            }
            html += '</div>';
            return html;
        }

        // è‡ªåŠ¨æ±‚è§£
        async function solve() {
            if (animationRunning) return;
            if (currentState.isGoal()) {
                alert('å·²ç»æ˜¯ç›®æ ‡çŠ¶æ€äº†ï¼');
                return;
            }
            
            document.getElementById('solveBtn').disabled = true;
            document.getElementById('status').className = 'status solving';
            document.getElementById('status').textContent = 'ğŸ” æ­£åœ¨æœç´¢æœ€ä¼˜è§£...';
            
            // å¼‚æ­¥æ‰§è¡Œæœç´¢
            setTimeout(() => {
                solution = aStarSearch(currentState);
                
                if (solution) {
                    solutionIndex = 0;
                    document.getElementById('status').className = 'status';
                    document.getElementById('status').textContent = `âœ… æ‰¾åˆ°è§£ï¼å…± ${solution.length - 1} æ­¥ã€‚ä½¿ç”¨ã€Œå•æ­¥æ‰§è¡Œã€æˆ–ã€Œè‡ªåŠ¨æ’­æ”¾ã€æŸ¥çœ‹è¿‡ç¨‹`;
                    document.getElementById('stepBtn').disabled = false;
                    document.getElementById('playBtn').disabled = false;
                } else {
                    document.getElementById('status').textContent = 'âŒ æ— è§£ï¼ˆç†è®ºä¸Šä¸å¯èƒ½ï¼‰';
                    document.getElementById('solveBtn').disabled = false;
                }
            }, 100);
        }
        
        // è‡ªåŠ¨æ’­æ”¾è§£å†³æ–¹æ¡ˆ
        async function autoPlay() {
            if (animationRunning || !solution) return;
            
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('playBtn').disabled = true;
            document.getElementById('status').className = 'status solving';
            
            animateSolution();
        }

        // åŠ¨ç”»å±•ç¤ºè§£å†³æ–¹æ¡ˆ
        async function animateSolution() {
            animationRunning = true;
            solutionIndex = 0;
            
            for (let i = 0; i < solution.length; i++) {
                currentState = solution[i];
                solutionIndex = i + 1;
                renderPuzzle('currentPuzzle', currentState.board, false);
                updateStats();
                
                // é«˜äº®å½“å‰æœç´¢èŠ‚ç‚¹
                const nodes = document.querySelectorAll('.search-node');
                nodes.forEach(n => n.classList.remove('current'));
                
                document.getElementById('status').textContent = `â–¶ï¸ è‡ªåŠ¨æ’­æ”¾ä¸­... æ­¥éª¤ ${i + 1}/${solution.length}`;
                
                await sleep(600);
            }
            
            animationRunning = false;
            document.getElementById('status').className = 'status solved';
            document.getElementById('status').textContent = 'ğŸ‰ æ±‚è§£å®Œæˆï¼';
            document.getElementById('solveBtn').disabled = false;
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('playBtn').disabled = true;
        }

        // å•æ­¥æ‰§è¡Œ
        function step() {
            if (!solution || solutionIndex >= solution.length) return;
            
            currentState = solution[solutionIndex];
            renderPuzzle('currentPuzzle', currentState.board, false);
            updateStats();
            
            // é«˜äº®å½“å‰æ­¥éª¤å¯¹åº”çš„æœç´¢èŠ‚ç‚¹
            const log = document.getElementById('searchLog');
            const nodes = log.querySelectorAll('.search-node');
            nodes.forEach((node, idx) => {
                node.classList.remove('current');
                // æ‰¾åˆ°åŒ¹é…å½“å‰çŠ¶æ€çš„èŠ‚ç‚¹
                const miniPuzzles = node.querySelectorAll('.mini-tile');
                let match = true;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const tileIndex = i * 3 + j;
                        const expectedValue = currentState.board[i][j] || '';
                        const actualValue = miniPuzzles[tileIndex].textContent;
                        if (String(expectedValue) !== actualValue) {
                            match = false;
                            break;
                        }
                    }
                    if (!match) break;
                }
                if (match) {
                    node.classList.add('current');
                    // åªåœ¨æœç´¢æ—¥å¿—å®¹å™¨å†…æ»šåŠ¨ï¼Œä¸å½±å“æ•´ä¸ªé¡µé¢
                    const logContainer = node.parentElement;
                    const nodeTop = node.offsetTop;
                    const containerHeight = logContainer.clientHeight;
                    const scrollPos = nodeTop - containerHeight / 2;
                    logContainer.scrollTop = scrollPos;
                }
            });
            
            solutionIndex++;
            
            // æ›´æ–°çŠ¶æ€ä¿¡æ¯
            document.getElementById('status').className = 'status solving';
            document.getElementById('status').textContent = `â­ï¸ æ­¥éª¤ ${solutionIndex}/${solution.length} - è¿˜å‰© ${solution.length - solutionIndex} æ­¥`;
            
            if (solutionIndex >= solution.length) {
                document.getElementById('status').className = 'status solved';
                document.getElementById('status').textContent = 'ğŸ‰ æ±‚è§£å®Œæˆï¼';
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('playBtn').disabled = true;
            }
        }

        // é‡ç½®
        function reset() {
            animationRunning = false;
            solution = null;
            solutionIndex = 0;
            exploredStates = 0;
            currentState = new PuzzleState([[1,2,3],[4,5,6],[7,8,0]], [2, 2]);
            renderPuzzle('currentPuzzle', currentState.board, true);
            updateStats();
            document.getElementById('searchLog').innerHTML = '';
            document.getElementById('status').className = 'status';
            document.getElementById('status').textContent = 'å·²é‡ç½®åˆ°åˆå§‹çŠ¶æ€';
            document.getElementById('solveBtn').disabled = false;
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('playBtn').disabled = true;
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            document.getElementById('exploredCount').textContent = exploredStates;
            document.getElementById('moveCount').textContent = currentState.g;
            document.getElementById('heuristicValue').textContent = currentState.h;
            
            // æ›´æ–°è®¡ç®—è¿‡ç¨‹
            updateCalculationDisplay();
            drawManhattanVisualization();
        }
        
        // æ›´æ–°è®¡ç®—è¿‡ç¨‹æ˜¾ç¤º
        function updateCalculationDisplay() {
            const g = currentState.g;
            const h = currentState.h;
            const f = currentState.f;
            
            // g å€¼è¯´æ˜
            document.getElementById('gCalc').innerHTML = `
                ä»åˆå§‹çŠ¶æ€ç§»åŠ¨äº† <strong style="color: #1976d2;">${g}</strong> æ­¥
            `;
            
            // h å€¼è¯¦ç»†è®¡ç®—
            const hDetails = calculateManhattanDetails();
            let hHtml = `æ‰€æœ‰æ•°å­—åˆ°ç›®æ ‡ä½ç½®çš„è·ç¦»ä¹‹å’Œï¼š<br>`;
            hHtml += `<div style="margin-top: 5px;">`;
            hDetails.forEach(detail => {
                if (detail.distance > 0) {
                    hHtml += `<span style="display: inline-block; margin: 2px 5px; padding: 2px 8px; background: rgba(255, 152, 0, 0.1); border-radius: 4px;">
                        ${detail.value}: ${detail.distance}æ­¥
                    </span>`;
                }
            });
            hHtml += `</div>`;
            hHtml += `<div style="margin-top: 8px; font-weight: 600; color: #f57c00;">
                æ€»è®¡ h = ${hDetails.map(d => d.distance).reduce((a, b) => a + b, 0)}
            </div>`;
            document.getElementById('hCalc').innerHTML = hHtml;
            
            // f å€¼è®¡ç®—
            document.getElementById('fCalc').innerHTML = `
                f = ${g} + ${h} = <strong style="color: #7b1fa2; font-size: 1.2em;">${f}</strong>
                <div style="font-size: 0.85em; color: #999; margin-top: 3px;">
                    (é¢„è®¡æ€»å…±éœ€è¦ ${f} æ­¥åˆ°è¾¾ç›®æ ‡)
                </div>
            `;
            
            // è®¡ç®—å¹¶æ˜¾ç¤ºä¸‹ä¸€æ­¥é€‰æ‹©
            updateNextMoveDisplay();
        }
        
        // æ˜¾ç¤ºä¸‹ä¸€æ­¥ç§»åŠ¨é€‰æ‹©
        function updateNextMoveDisplay() {
            const nextMoveSection = document.getElementById('nextMoveSection');
            const nextMoveCalc = document.getElementById('nextMoveCalc');
            
            // å¦‚æœå·²ç»æ˜¯ç›®æ ‡çŠ¶æ€ï¼Œéšè—è¿™ä¸ªåŒºåŸŸ
            if (currentState.isGoal()) {
                nextMoveSection.style.display = 'none';
                return;
            }
            
            nextMoveSection.style.display = 'block';
            
            // è·å–æ‰€æœ‰å¯èƒ½çš„ä¸‹ä¸€æ­¥
            const possibleMoves = currentState.getMoves();
            
            if (possibleMoves.length === 0) {
                nextMoveCalc.innerHTML = 'æ²¡æœ‰å¯ç”¨çš„ç§»åŠ¨';
                return;
            }
            
            // æŒ‰ f å€¼æ’åº
            possibleMoves.sort((a, b) => a.f - b.f);
            
            let html = `<div style="margin-bottom: 8px; color: #666;">
                è¯„ä¼°æ‰€æœ‰å¯èƒ½çš„ç§»åŠ¨ï¼ˆç©ºæ ¼å¯ä»¥ç§»åŠ¨åˆ°çš„ä½ç½®ï¼‰ï¼š
            </div>`;
            
            html += `<div style="display: grid; gap: 8px;">`;
            
            possibleMoves.forEach((move, idx) => {
                const [emptyRow, emptyCol] = move.emptyPos;
                const movedTile = currentState.board[emptyRow][emptyCol];
                const direction = getDirection(currentState.emptyPos, move.emptyPos);
                const isBest = idx === 0;
                
                html += `<div style="
                    padding: 8px;
                    background: ${isBest ? 'rgba(76, 175, 80, 0.15)' : 'rgba(0,0,0,0.03)'};
                    border-radius: 6px;
                    border: 2px solid ${isBest ? '#4caf50' : '#e0e0e0'};
                    ${isBest ? 'box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);' : ''}
                ">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            ${isBest ? '<strong style="color: #2e7d32;">âœ“ æœ€ä¼˜é€‰æ‹©ï¼š</strong>' : ''}
                            ç§»åŠ¨æ•°å­— <strong>${movedTile}</strong> åˆ°${direction}
                        </div>
                        <div style="font-family: 'Courier New', monospace; font-size: 0.9em;">
                            <span style="color: #1976d2;">g=${move.g}</span> + 
                            <span style="color: #f57c00;">h=${move.h}</span> = 
                            <strong style="color: ${isBest ? '#2e7d32' : '#7b1fa2'};">f=${move.f}</strong>
                        </div>
                    </div>
                </div>`;
            });
            
            html += `</div>`;
            
            html += `<div style="margin-top: 10px; padding: 8px; background: rgba(76, 175, 80, 0.1); border-radius: 6px; font-size: 0.9em;">
                ğŸ’¡ A* ç®—æ³•é€‰æ‹© <strong style="color: #2e7d32;">f å€¼æœ€å°</strong> çš„ç§»åŠ¨ï¼ˆf=${possibleMoves[0].f}ï¼‰ï¼Œ
                å› ä¸ºå®ƒé¢„è®¡èƒ½ä»¥æœ€å°‘çš„æ€»æ­¥æ•°åˆ°è¾¾ç›®æ ‡ï¼
            </div>`;
            
            nextMoveCalc.innerHTML = html;
        }
        
        // è·å–ç§»åŠ¨æ–¹å‘æè¿°
        function getDirection(fromPos, toPos) {
            const [fromRow, fromCol] = fromPos;
            const [toRow, toCol] = toPos;
            
            if (toRow < fromRow) return 'ä¸Šæ–¹';
            if (toRow > fromRow) return 'ä¸‹æ–¹';
            if (toCol < fromCol) return 'å·¦ä¾§';
            if (toCol > fromCol) return 'å³ä¾§';
            return '';
        }
        
        // è®¡ç®—æ¯ä¸ªæ•°å­—çš„æ›¼å“ˆé¡¿è·ç¦»è¯¦æƒ…
        function calculateManhattanDetails() {
            const goal = [[1,2,3],[4,5,6],[7,8,0]];
            const details = [];
            
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const value = currentState.board[i][j];
                    if (value !== 0) {
                        // æ‰¾åˆ°ç›®æ ‡ä½ç½®
                        for (let gi = 0; gi < 3; gi++) {
                            for (let gj = 0; gj < 3; gj++) {
                                if (goal[gi][gj] === value) {
                                    const distance = Math.abs(i - gi) + Math.abs(j - gj);
                                    details.push({
                                        value: value,
                                        currentPos: [i, j],
                                        goalPos: [gi, gj],
                                        distance: distance
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            return details.sort((a, b) => a.value - b.value);
        }
        
        // ç»˜åˆ¶æ›¼å“ˆé¡¿è·ç¦»å¯è§†åŒ–
        function drawManhattanVisualization() {
            const canvas = document.getElementById('manhattanViz');
            const ctx = canvas.getContext('2d');
            const size = 300;
            const cellSize = 90;
            const padding = 15;
            
            ctx.clearRect(0, 0, size, size);
            
            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(padding + i * cellSize, padding);
                ctx.lineTo(padding + i * cellSize, padding + cellSize * 3);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(padding, padding + i * cellSize);
                ctx.lineTo(padding + cellSize * 3, padding + i * cellSize);
                ctx.stroke();
            }
            
            const details = calculateManhattanDetails();
            const goal = [[1,2,3],[4,5,6],[7,8,0]];
            
            // ç»˜åˆ¶ç®­å¤´å’Œè·ç¦»
            details.forEach((detail, idx) => {
                if (detail.distance > 0) {
                    const [ci, cj] = detail.currentPos;
                    const [gi, gj] = detail.goalPos;
                    
                    const cx = padding + cj * cellSize + cellSize / 2;
                    const cy = padding + ci * cellSize + cellSize / 2;
                    const gx = padding + gj * cellSize + cellSize / 2;
                    const gy = padding + gi * cellSize + cellSize / 2;
                    
                    // ç»˜åˆ¶ç®­å¤´
                    const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
                    ctx.strokeStyle = colors[idx % colors.length];
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 3]);
                    
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(gx, gy);
                    ctx.stroke();
                    
                    // ç®­å¤´å¤´éƒ¨
                    const angle = Math.atan2(gy - cy, gx - cx);
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(gx, gy);
                    ctx.lineTo(gx - 10 * Math.cos(angle - Math.PI / 6), gy - 10 * Math.sin(angle - Math.PI / 6));
                    ctx.moveTo(gx, gy);
                    ctx.lineTo(gx - 10 * Math.cos(angle + Math.PI / 6), gy - 10 * Math.sin(angle + Math.PI / 6));
                    ctx.stroke();
                    
                    // æ ‡æ³¨è·ç¦»
                    const mx = (cx + gx) / 2;
                    const my = (cy + gy) / 2;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(mx - 12, my - 10, 24, 20);
                    ctx.fillStyle = colors[idx % colors.length];
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(detail.distance.toString(), mx, my);
                }
            });
            
            // ç»˜åˆ¶æ•°å­—
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const value = currentState.board[i][j];
                    const goalValue = goal[i][j];
                    
                    const x = padding + j * cellSize;
                    const y = padding + i * cellSize;
                    
                    if (value !== 0) {
                        // å½“å‰æ•°å­—
                        const isCorrect = value === goalValue;
                        ctx.fillStyle = isCorrect ? '#4caf50' : '#ff9800';
                        ctx.fillRect(x + 5, y + 5, cellSize - 10, cellSize - 10);
                        
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 32px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(value.toString(), x + cellSize / 2, y + cellSize / 2);
                        
                        // å°æ ‡ç­¾æ˜¾ç¤ºç›®æ ‡ä½ç½®
                        if (!isCorrect) {
                            const detail = details.find(d => d.value === value);
                            if (detail) {
                                const [gi, gj] = detail.goalPos;
                                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                                ctx.font = '10px Arial';
                                ctx.fillText(`â†’(${gi},${gj})`, x + cellSize / 2, y + cellSize - 8);
                            }
                        }
                    } else {
                        // ç©ºæ ¼
                        ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
                        ctx.fillRect(x + 5, y + 5, cellSize - 10, cellSize - 10);
                    }
                }
            }
            
            // æ›´æ–°è¯¦ç»†è¯´æ˜
            let detailsHtml = `<div style="font-weight: 600; margin-bottom: 5px;">è·ç¦»è®¡ç®—ï¼š</div>`;
            details.forEach(detail => {
                if (detail.distance > 0) {
                    const [ci, cj] = detail.currentPos;
                    const [gi, gj] = detail.goalPos;
                    detailsHtml += `<div style="margin: 3px 0;">
                        æ•°å­— <strong>${detail.value}</strong>: 
                        (${ci},${cj}) â†’ (${gi},${gj}) = 
                        |${ci}-${gi}| + |${cj}-${gj}| = 
                        <strong>${detail.distance}</strong>
                    </div>`;
                }
            });
            document.getElementById('manhattanDetails').innerHTML = detailsHtml;
        }

        // å·¥å…·å‡½æ•°
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // åˆå§‹åŒ–
        init();
    </script>
</body>
</html>
